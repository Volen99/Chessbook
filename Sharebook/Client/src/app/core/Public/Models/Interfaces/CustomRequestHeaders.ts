import IEnumerable from "../../../../c#-objects/TypeScript.NET-Core/packages/Core/source/Collections/Enumeration/IEnumerable";
import {Dictionary} from 'src/app/c#-objects/TypeScript.NET-Core/packages/Core/source/Collections/Dictionaries/Dictionary';
import {IEnumerator} from 'src/app/c#-objects/TypeScript.NET-Core/packages/Core/source/Collections/Enumeration/IEnumerator';

export enum CustomHeaderWill {
  // <para>If a header with the same name was generated by Tweetinvi, its value will be overriden by the custom header value</para>
  // <para>If no header with the custom header name was generated by Tweetinvi, the header will be created</para>
  OverrideGeneratedHeaders,

  // <para>If a header with the same name was generated by Tweetinvi, the value will be added to the list of the header values</para>
  // <para>If no header with the custom header name was generated by Tweetinvi, the header will be created</para>
  BeAddedToGeneratedHeaders,

  // Removes any header generated by Tweetinvi
  RemoveGeneratedHeaders
}

export class CustomHeader {
  constructor(key: string) {
    this.key = key;
    this.values = new Array<string>();
    this.behaviour = CustomHeaderWill.OverrideGeneratedHeaders;
  }

  public key: string;
  public values: Array<string>;
  public behaviour: CustomHeaderWill;
}

export class CustomRequestHeaders implements Array<CustomHeader> {
  private _customHeaders: Dictionary<string, CustomHeader>;

  constructor() {
    this._customHeaders = new Dictionary<string, CustomHeader>();
  }

  isEndless?: boolean;

  public add(keyOrCustomHeader: string | CustomHeader, valueOrValues: string | Array<string> | IEnumerable<string>,
             behaviour?: CustomHeaderWill): void {
    if (CustomRequestHeaders.isCustomHeader(keyOrCustomHeader)) {
      if (keyOrCustomHeader.values == null) {
        this._customHeaders.removeByKey(keyOrCustomHeader.key);
      } else {
        this._customHeaders[keyOrCustomHeader.key] = keyOrCustomHeader;
      }

      return;
    } else {
      let values;
      let behaviourCurrent;
      if (typeof valueOrValues === 'string') {
        values = [valueOrValues];
      } else {
        values = valueOrValues;
      }
      if (behaviour) {
        behaviourCurrent = behaviour;
      } else {
        behaviour = CustomHeaderWill.OverrideGeneratedHeaders;
      }

      let currentValue: CustomHeader;
      if (this._customHeaders.containsKey(keyOrCustomHeader) === false) {  // TODO: check c# code coz many changes
        currentValue = new CustomHeader(keyOrCustomHeader);
      }

      currentValue.behaviour = behaviour;
      currentValue.values.add(values);                     // AddRange
      this._customHeaders[keyOrCustomHeader] = currentValue;
    }
  }

  public get(key: string): CustomHeader {
    return this._customHeaders[key];
  }

  public remove(key: string): void {
    this._customHeaders.removeByKey(key);
  }

  // public CustomHeader this[string key] => Get(key);

  getEnumerator(): IEnumerator<CustomHeader> {
    return; // this._customHeaders.values.getEnumerator();
  }

  private static isCustomHeader(keyOrCustomHeader: string | CustomHeader): keyOrCustomHeader is CustomHeader {
    return (keyOrCustomHeader as CustomHeader).key !== undefined;
  }

  // public IEnumerator<CustomHeader> GetEnumerator()
  // {
  //   return _customHeaders.Values.GetEnumerator();
  // }
  //
  // IEnumerator IEnumerable.GetEnumerator()
  // {
  //   return GetEnumerator();
  // }

}
